CLASS ZCL_COC_FIELD_SELECTION DEFINITION
	PUBLIC
	FINAL
	CREATE PUBLIC.
	
PUBLIC SECTION.
	
	DATA TITLE_POPUP TYPE STRING.
	DATA T_FCAT_LEFT TYPE LVC_T_FCAT.
	DATA T_FCAT_RIGHT TYPE LVC_T_FCAT.
	DATA DATA_LEFT TYPE REF TO DATA.
	DATA DATA_RIGHT TYPE REF TO DATA.
	DATA MIN_COLUMNS TYPE I.
	DATA MAX_COLUMNS TYPE I.
	DATA DD_LEFT TYPE REF TO CL_DRAGDROP.
	DATA DD_RIGHT TYPE REF TO CL_DRAGDROP.
	DATA BUTTON_REMOVE TYPE REF TO CL_DD_BUTTON_ELEMENT.
	DATA BUTTON_ADD TYPE REF TO CL_DD_BUTTON_ELEMENT.
	DATA HTML TYPE REF TO CL_GUI_HTML_VIEWER.
	DATA FORM_AREA TYPE REF TO CL_DD_FORM_AREA.
	DATA DOCUMENT TYPE REF TO CL_DD_DOCUMENT.
	DATA HANDLE_LEFT TYPE I.
	DATA HANDLE_RIGHT TYPE I.
	DATA ALV_L TYPE REF TO ZCL_COC_ALV.
	DATA ALV_R TYPE REF TO ZCL_COC_ALV.

	METHODS CONSTRUCTOR
	  IMPORTING 
		!I_TITLE_POPUP TYPE STRING OPTIONAL
		!I_MIN_COLUMNS TYPE I OPTIONAL
		!I_MAX_COLUMNS TYPE I OPTIONAL
		!IT_FCAT_LEFT TYPE LVC_T_FCAT
		!IT_FCAT_RIGHT TYPE LVC_T_FCAT.
	METHODS GET_HANDLE_DD
	  IMPORTING
		!DD_OBJECT TYPE REF TO CL_DRAGDROP
	  RETURNING 
		VALUE(HANDLE) TYPE I.
	METHODS DISPLAY
	  CHANGING
	  	!CT_DATA_LEFT TYPE STANDARD TABLE OPTIONAL
		!CT_DATA_RIGHT TYPE STANDARD TABLE OPTIONAL.
	METHODS FREE.
PROTECTED SECTION.
PRIVATE SECTION.

	METHODS HANDLE_ONDRAG
	  FOR EVENT ONDRAG OF CL_GUI_ALV_GRID
	  IMPORTING
		!SENDER
		!E_ROW
		!E_COLUMN
		!ES_ROW_NO
		!E_DRAGDROPOBJ.
	METHODS HANDLE_ONDROP
	  FOR EVENT ONDROP OF CL_GUI_ALV_GRID
	  IMPORTING
		!SENDER
		!E_ROW
		!E_COLUMN
		!ES_ROW_NO
		!E_DRAGDROPOBJ.
	METHODS HANDLE_ONDROPCOMPLETE
	  FOR EVENT ONDROPCOMPLETE OF CL_GUI_ALV_GRID
	  IMPORTING
		!SENDER
		!E_ROW
		!E_COLUMN
		!ES_ROW_NO
		!E_DRAGDROPOBJ.
	METHODS HANDLE_BUTTON_ADD
	  FOR EVENT CLICKED OF CL_DD_BUTTON_ELEMENT.
	METHODS HANDLE_BUTTON_REMOVE
	  FOR EVENT CLICKED OF CL_DD_BUTTON_ELEMENT.
	METHODS HANDLE_DOUBLE_CLICK
	  FOR EVENT DOUBLE_CLICK OF CL_GUI_ALV_GRID
	  IMPORTING
		!SENDER
		!E_ROW
		!E_COLUMN
		!ES_ROW_NO.
	METHODS MOVE_OUTSIDE
	  IMPORTING
		!FROM TYPE C
		!TO TYPE C
		!TO_INDEX TYPE INT4 OPTIONAL
	  CHANGING
		!T_ROWS TYPE LVC_T_ROID.
	METHODS MOVE_INSIDE
	  IMPORTING
		!FROM TYPE C
		!TO_INDEX TYPE INT4 OPTIONAL
	  CHANGING
		!T_ROWS TYPE LVC_T_ROID.
ENDCLASS.



CLASS ZCL_COC_FIELD_SELECTION IMPLEMENTATION.











	METHOD CONSTRUCTOR.
		
		"TITLE
		TITLE_POPUP = I_TITLE_POPUP.

		"MIN/MAX ENTRIES
		MIN_COLUMNS = I_MIN_COLUMNS.
		MAX_COLUMNS = I_MAX_COLUMNS.

		"FIELD CATALOG
		T_FCAT_LEFT  = IT_FCAT_LEFT.
		T_FCAT_RIGHT = IT_FCAT_RIGHT.

		"ALV OBJECT
		ALV_L = NEW #( ).
		ALV_R = NEW #( ).

	ENDMETHOD.








	METHOD DISPLAY.

		CHECK ALV_L->MO_DOCKING IS NOT BOUND.

*-----------------------------------------------------------------------
* PERFORM CREATE_OBJ
*-----------------------------------------------------------------------
		"1. CREATE CONTAINER
		ALV_L->MO_DOCKING = NEW #( SIDE = CL_GUI_DOCKING_CONTAINER=>DOCK_AT_TOP EXTENSION = 600 ).

		"2. SPLIT LEFT/RIGHT AREA
		IF ALV_L->MO_SPLIT IS NOT BOUND.
			ALV_L->MO_SPLIT = NEW #( ROWS = 1 COLUMNS = 2 PARENT = ALV_L->MO_DOCKING ).
			ALV_L->MO_SPLIT->SET_COLUMN_WIDTH( ID = 1 WIDTH = 32 ).
		ENDIF.

		CHECK ALV_L->MO_SPLIT IS BOUND.

		"3. ASSGIN LEFT CONTAINER TO LEFT SPLITTER
		ALV_L->MO_LEFT = ALV_L->MO_SPLIT->GET_CONTAINER( ROW = 1 COLUMN = 1 ).

		"4. ASSGIN RIGHT CONTAINER TO RIGHT SPLITTER
		ALV_L->MO_RIGHT = ALV_L->MO_SPLIT->GET_CONTAINER( ROW = 1 COLUMN = 2 ).

		"5. SPLIT RIGHT CONTAINER TO BUTTON AREA
		ALV_R->MO_SPLIT = NEW #( ROWS = 1 COLUMNS = 2 PARENT = ALV_L->MO_RIGHT ).
		ALV_R->MO_SPLIT->SET_COLUMN_SASH( ID = 1 TYPE = ALV_R->MO_SPLIT->TYPE_MOVABLE VALUE = 0 ).
		ALV_R->MO_SPLIT->SET_COLUMN_MODE( MODE = ALV_R->MO_SPLIT->MODE_ABSOLUTE ).
		ALV_R->MO_SPLIT->SET_COLUMN_WIDTH( ID = 1 WIDTH = 41 ).

		ALV_R->MO_MAIN  = ALV_R->MO_SPLIT->GET_CONTAINER( ROW = 1 COLUMN = 1 ).
		ALV_R->MO_RIGHT = ALV_R->MO_SPLIT->GET_CONTAINER( ROW = 1 COLUMN = 2 ).

		"6. ALV GRID OBJECT
		IF ALV_L->MO_LEFT IS BOUND AND ALV_L->MO_GRID IS NOT BOUND.
			ALV_L->MO_GRID = NEW #( I_PARENT = ALV_L->MO_LEFT ).
		ENDIF.

		IF ALV_R->MO_RIGHT IS BOUND AND ALV_R->MO_GRID IS NOT BOUND.
			ALV_R->MO_GRID = NEW #( I_PARENT = ALV_R->MO_RIGHT ).
		ENDIF.

		"7. CREATE BUTTON
		"CREATE OBJECT
		HTML = NEW #( ALV_R->MO_MAIN ).
		DOCUMENT = NEW #( ).

		"CONNECT IT TO HTML VIEW
		DOCUMENT->HTML_CONTROL = HTML.

		"INITIALIZE
		DOCUMENT->INITIALIZE_DOCUMENT( NO_MARGINS = ABAP_TRUE ).

		DATA(STYLE) = |<BODY style="overflow:hidden">|.
		DOCUMENT->ADD_STATIC_HTML( STRING_WITH_HTML = STYLE ).

		"OPEN A BLOCK AND SET MARGINS
		STYLE = |<DIV style="margin-top:47vh; margin-left:1pt">|.
		DOCUMENT->ADD_STATIC_HTML( STRING_WITH_HTML = STYLE ).

		"ADD A FORM
		DOCUMENT->ADD_FORM( IMPORTING FORMAREA = FORM_AREA ).

		"BUTTON 'add field'
		FORM_AREA->ADD_BUTTON( EXPORTING SAP_ICON = 'ICON_COLUMN_RIGHT'
										 TOOLTIP  = CONV #( |필드 추가| )
										 NAME     = 'BUT_ADD'
							   IMPORTING BUTTON   = BUTTON_ADD ).

		"BUTTON 'remove field'
		FORM_AREA->ADD_BUTTON( EXPORTING SAP_ICON = 'ICON_COLUMN_LEFT'
										 TOOLTIP  = CONV #( |필드 제거| )
										 NAME     = 'BUT_DEL'
							   IMPORTING BUTTON   = BUTTON_REMOVE ).

		"CLOSE THIS BLOCK
		DOCUMENT->ADD_STATIC_HTML( STRING_WITH_HTML = '</DIV>' ).
		DOCUMENT->ADD_STATIC_HTML( STRING_WITH_HTML = '</BODY>' ).

		"SHOW DS SELECTOR
		DOCUMENT->MERGE_DOCUMENT( ).

		"USE CONTAINER IN THE PUBLIC ATTRIBUTE HTML_CONTROL
		DOCUMENT->DISPLAY_DOCUMENT( REUSE_CONTROL = ABAP_TRUE ).

*-----------------------------------------------------------------------
* PERFORM SET_DRDN
*-----------------------------------------------------------------------
		"SET D&D-BEHAVIOUR FOR LEFT GRID
		DD_LEFT = NEW #( ).

		"MOVE BETWEEN GRIDS
		DD_LEFT->ADD( FLAVOR     = 'MOVE'
					  DRAGSRC    = ABAP_TRUE
					  DROPTARGET = ABAP_TRUE
					  EFFECT     = CL_DRAGDROP=>MOVE ).

		"MOVE TO EXTERNAL DOCKING CONTAINER
		DD_LEFT->ADD( FLAVOR     = 'MOVE2DOC'
					  DRAGSRC    = ABAP_TRUE
					  DROPTARGET = ABAP_FALSE
					  EFFECT     = CL_DRAGDROP=>MOVE ).

		"SET D&D-BEHAVIOUR FOR RIGHT GRID
		DD_RIGHT = NEW #( ).

		"MOVE BETWEEN GRIDS
		DD_RIGHT->ADD( FLAVOR     = 'MOVE'
					   DRAGSRC    = ABAP_TRUE
					   DROPTARGET = ABAP_TRUE
					   EFFECT     = CL_DRAGDROP=>MOVE ).

		"MOVE WITHIN GRID
		DD_RIGHT->ADD( FLAVOR     = 'MOVE_INSIDE'
					  DRAGSRC    = ABAP_TRUE
					  DROPTARGET = ABAP_TRUE
					  EFFECT     = CL_DRAGDROP=>MOVE ).

*-----------------------------------------------------------------------
* PERFORM SET_EVENT
*-----------------------------------------------------------------------
		ALV_L->MO_GRID->REGISTER_EDIT_EVENT( CL_GUI_ALV_GRID=>MC_EVT_MODIFIED ).
		ALV_R->MO_GRID->REGISTER_EDIT_EVENT( CL_GUI_ALV_GRID=>MC_EVT_MODIFIED ).

		SET HANDLER HANDLE_ONDRAG
					HANDLE_ONDROP
					HANDLE_ONDROPCOMPLETE
					HANDLE_DOUBLE_CLICK  FOR: ALV_L->MO_GRID,
											  ALV_R->MO_GRID.
											  
		SET HANDLER HANDLE_BUTTON_ADD    FOR BUTTON_ADD.
		SET HANDLER HANDLE_BUTTON_REMOVE FOR BUTTON_REMOVE.

*-----------------------------------------------------------------------
* PERFORM SET_TOOLBAR
*-----------------------------------------------------------------------
		ALV_L->SET_TOOLBAR_STD( '3' ).
		ALV_R->SET_TOOLBAR_STD( '3' ).

*-----------------------------------------------------------------------
* PERFORM SET_LAYOUT
*-----------------------------------------------------------------------
		ALV_L->MS_LAYOUT = VALUE #( NO_ROWMARK = ABAP_ON
									COL_OPT    = ABAP_ON
									NO_HGRIDLN = ABAP_ON
									NO_VGRIDLN = ABAP_ON
									SEL_MODE   = 'C'
									STYLEFNAME = 'CELLTAB'
									GRID_TITLE = '사용 가능한 열'
									S_DRAGDROP = VALUE #( CNTR_DDID = GET_HANDLE_DD( DD_LEFT ) 
									                      ROW_DDID  = GET_HANDLE_DD( DD_LEFT ) ) ).

		ALV_R->MS_LAYOUT = VALUE #( NO_ROWMARK = ABAP_OFF "ABAP_ON
									COL_OPT    = ABAP_ON
									NO_HGRIDLN = ABAP_ON
									NO_VGRIDLN = ABAP_ON
									SEL_MODE   = 'C'
									STYLEFNAME = 'CELLTAB'
									GRID_TITLE = '선택된 열'
									S_DRAGDROP = VALUE #( CNTR_DDID = GET_HANDLE_DD( DD_RIGHT ) 
									                      ROW_DDID  = GET_HANDLE_DD( DD_LEFT ) ) ).

*-----------------------------------------------------------------------
* PERFORM SHOW_ALV_0200 using GR_ALV1 GR_FS->T_FCAT_LEFT GR_DATA_LEFT
*-----------------------------------------------------------------------
		ASSIGN DATA_LEFT->* TO FIELD-SYMBOL(<FS_DATA_L>).

		CALL METHOD ALV_L->MO_GRID->SET_TABLE_FOR_FIRST_DISPLAY
		  EXPORTING
			IS_VARIANT                      = ALV_L->MS_VARIANT
			I_SAVE                          = ALV_L->MV_VARIANT_SAVE
			I_DEFAULT                       = ABAP_ON
			IS_LAYOUT                       = ALV_L->MS_LAYOUT
			IT_TOOLBAR_EXCLUDING            = ALV_L->MT_UI_FUNCTIONS
		  CHANGING
			IT_OUTTAB                       = <FS_DATA_L>
			IT_FIELDCATALOG                 = T_FCAT_LEFT
			IT_SORT                         = ALV_L->MT_SORT
		  EXCEPTIONS
			INVALID_PARAMETER_COMBINATION   = 1
			PROGRAM_ERROR                   = 2
			TOO_MANY_LINES                  = 3
			OTHERS                          = 4.

*-----------------------------------------------------------------------
* PERFORM SHOW_ALV_0200 using GR_ALV2 GR_FS->T_FCAT_RIGHT GR_DATA_RIGHT
*-----------------------------------------------------------------------
		ASSIGN DATA_RIGHT->* TO FIELD-SYMBOL(<FS_DATA_R>).

		CALL METHOD ALV_R->MO_GRID->SET_TABLE_FOR_FIRST_DISPLAY
		  EXPORTING
			IS_VARIANT                      = ALV_R->MS_VARIANT
			I_SAVE                          = ALV_R->MV_VARIANT_SAVE
			I_DEFAULT                       = ABAP_ON
			IS_LAYOUT                       = ALV_R->MS_LAYOUT
			IT_TOOLBAR_EXCLUDING            = ALV_R->MT_UI_FUNCTIONS
		  CHANGING
			IT_OUTTAB                       = <FS_DATA_R>
			IT_FIELDCATALOG                 = T_FCAT_RIGHT
			IT_SORT                         = ALV_R->MT_SORT
		  EXCEPTIONS
			INVALID_PARAMETER_COMBINATION   = 1
			PROGRAM_ERROR                   = 2
			TOO_MANY_LINES                  = 3
			OTHERS                          = 4.

		CALL METHOD CL_GUI_CFW=>FLUSH.

	ENDMETHOD.






	METHOD FREE.

		ALV_L->MO_DOCKING->FREE( ).
		CLEAR ALV_L->MO_DOCKING.
		
	ENDMETHOD.








	METHOD GET_HANDLE_DD.

		DD_OBJECT->GET_HANDLE( IMPORTING HANDLE = HANDLE ).

	ENDMETHOD.






	METHOD HANDLE_BUTTON_REMOVE.

		ALV_L->MO_GRID->GET_SELECTED_ROWS( IMPORTING ET_ROW_NO = DATA(T_ROWS) ).

		MOVE_OUTSIDE( EXPORTING FROM = ZCOC_L TO = ZCOC_R
					  CHANGING  T_ROWS = T_ROWS ).
					  
	ENDMETHOD.
	





	METHOD HANDLE_BUTTON_ADD.

		ALV_R->MO_GRID->GET_SELECTED_ROWS( IMPORTING ET_ROW_NO = DATA(T_ROWS) ).

		MOVE_OUTSIDE( EXPORTING FROM = ZCOC_R TO = ZCOC_L
					  CHANGING  T_ROWS = T_ROWS ).
					  
	ENDMETHOD.
	









	METHOD HANDLE_DOUBLE_CLICK.

		DATA(T_ROWS) = VALUE LVC_T_ROID( ( ES_ROW_NO ) ).

		CASE SENDER.

			WHEN ALV_L->MO_GRID. "LEFT -> RIGHT

				MOVE_OUTSIDE( EXPORTING FROM = ZCOC_L TO = ZCOC_R
							  CHANGING  T_ROWS = T_ROWS ).

			WHEN ALV_R->MO_GRID. "RIGHT -> LEFT

				MOVE_OUTSIDE( EXPORTING FROM = ZCOC_R TO = ZCOC_L
							  CHANGING  T_ROWS = T_ROWS ).

		ENDCASE.

	ENDMETHOD.











	METHOD HANDLE_ONDRAG.

		DATA(DATAOBJ) = NEW ZCL_COC_FIELD_SELECTION_OBJ( ).

		FIELD-SYMBOLS: <FS_ALV> TYPE REF TO ZCL_COC_ALV.

		CASE SENDER.
			WHEN ALV_L->MO_GRID.
				DATAOBJ->MOVE_FROM = ZCOC_L.
			WHEN ALV_R->MO_GRID.
				DATAOBJ->MOVE_FROM = ZCOC_R.
		ENDCASE.	  

		DATA(LV_ALV) = |ALV_{ DATAOBJ->MOVE_FROM }|.
		ASSIGN (LV_ALV) TO <FS_ALV>.

		<FS_ALV>->MO_GRID->GET_SELECTED_ROWS( IMPORTING ET_ROW_NO = DATAOBJ->T_ROWS ).
		IF DATAOBJ->T_ROWS IS INITIAL.

			<FS_ALV>->MO_GRID->GET_SELECTED_CELLS( IMPORTING ET_CELL = DATA(T_CELL) ).
			IF T_CELL IS NOT INITIAL.
				DATAOBJ->T_ROWS = VALUE #( ( ROW_ID = CONV #( T_CELL[ 1 ]-ROW_ID-INDEX ) ) ).
			ENDIF.

		ENDIF.

		E_DRAGDROPOBJ->OBJECT = DATAOBJ.

	ENDMETHOD.
	










	METHOD HANDLE_ONDROP.

		DATA: DATAOBJ TYPE REF TO ZCL_COC_FIELD_SELECTION_OBJ.

		FIELD-SYMBOLS: <FS_DATA_L> TYPE STANDARD TABLE,
					   <FS_DATA_R> TYPE STANDARD TABLE.

*-----------------------------------------------------------------*
* VERY IMPORTANT : 'E_DRAGDROPOBJ->OBJECT' can have any instance type
* The needed cast type may lead to a system-exception if the cast
* can not be performed.
* For this reason : Use ALWAYS the Catch-Statement to make sure
* that the drag&drop-Operation is aborted properly.
*-----------------------------------------------------------------*
		CATCH SYSTEM-EXCEPTIONS MOVE_CAST_ERROR = 1.

			DATAOBJ ?= E_DRAGDROPOBJ->OBJECT.

			ASSIGN DATA_LEFT->*  TO <FS_DATA_L>.
			ASSIGN DATA_RIGHT->* TO <FS_DATA_R>.

			CASE DATAOBJ->MOVE_FROM.

				WHEN ZCOC_L. "FROM LEFT

					CASE SENDER.

						WHEN ALV_L->MO_GRID. "TO LEFT
			
							MOVE_INSIDE( EXPORTING FROM = ZCOC_L
							                       TO_INDEX = SWITCH #( E_ROW-INDEX WHEN 0 THEN LINES( <FS_DATA_L> ) ELSE E_ROW-INDEX )
										 CHANGING  T_ROWS = DATAOBJ->T_ROWS ).
			
						WHEN ALV_R->MO_GRID. "TO RIGHT
			
							MOVE_OUTSIDE( EXPORTING FROM = ZCOC_L 
													TO   = ZCOC_R
													TO_INDEX = SWITCH #( E_ROW-INDEX WHEN 0 THEN LINES( <FS_DATA_R> ) + 1 ELSE E_ROW-INDEX )
										  CHANGING  T_ROWS = DATAOBJ->T_ROWS ).
			
					ENDCASE.

				WHEN ZCOC_R. "FROM RIGHT

					CASE SENDER.

						WHEN ALV_L->MO_GRID. "TO LEFT
			
							MOVE_OUTSIDE( EXPORTING FROM = ZCOC_R
													TO   = ZCOC_L
													TO_INDEX = SWITCH #( E_ROW-INDEX WHEN 0 THEN LINES( <FS_DATA_L> ) + 1 ELSE E_ROW-INDEX )
										  CHANGING  T_ROWS = DATAOBJ->T_ROWS ).
			
						WHEN ALV_R->MO_GRID. "TO RIGHT
			
							MOVE_INSIDE( EXPORTING FROM = ZCOC_R
												   TO_INDEX = SWITCH #( E_ROW-INDEX WHEN 0 THEN LINES( <FS_DATA_R> ) ELSE E_ROW-INDEX )
										 CHANGING  T_ROWS = DATAOBJ->T_ROWS ).
			
					ENDCASE.

			ENDCASE.

		ENDCATCH.

		IF SY-SUBRC <> 0.
			CALL METHOD E_DRAGDROPOBJ->ABORT.
		ENDIF.

	ENDMETHOD.











	METHOD HANDLE_ONDROPCOMPLETE.

	ENDMETHOD.











	METHOD MOVE_OUTSIDE.

		DATA: LT_INSTED_ROW TYPE LVC_T_ROID.

		FIELD-SYMBOLS: <FS_ALV_FR>  TYPE REF TO ZCL_COC_ALV,
					   <FS_ALV_TO>  TYPE REF TO ZCL_COC_ALV,
					   <FS_DATA_FR> TYPE STANDARD TABLE,
					   <FS_DATA_TO> TYPE STANDARD TABLE.

		DATA(LV_FR) = |ALV_{ FROM }|.
		DATA(LV_TO) = |ALV_{ TO }|.
		ASSIGN (LV_FR) TO <FS_ALV_FR>.
		ASSIGN (LV_TO) TO <FS_ALV_TO>.
		               
		CASE FROM.
			WHEN ZCOC_L.
				ASSIGN DATA_LEFT->*  TO <FS_DATA_FR>.
				ASSIGN DATA_RIGHT->* TO <FS_DATA_TO>.
			WHEN ZCOC_R.
				ASSIGN DATA_RIGHT->* TO <FS_DATA_FR>.
				ASSIGN DATA_LEFT->*  TO <FS_DATA_TO>.
		ENDCASE.

		IF T_ROWS IS INITIAL.
			MESSAGE S552(KE0C) DISPLAY LIKE ZCOC_E.
			EXIT.
		ENDIF.

		SORT T_ROWS BY ROW_ID.

		"FROM -> TO
		" - CHECK "TO" POSITION
		IF TO_INDEX IS NOT INITIAL.
			DATA(TO_ROWS) = VALUE LVC_T_ROID( ( ROW_ID = CONV #( TO_INDEX ) ) ).
		ELSE.
			<FS_ALV_TO>->MO_GRID->GET_SELECTED_ROWS( IMPORTING ET_ROW_NO = TO_ROWS ).
		ENDIF.

		IF TO_ROWS IS INITIAL.
			DATA(LV_INS_IDX) = LINES( <FS_DATA_TO> ) + 1.
		ELSE.
			SORT TO_ROWS BY ROW_ID.
			LV_INS_IDX = TO_ROWS[ 1 ]-ROW_ID.
		ENDIF.

		" - SAVE INSERTED INDEX
		LOOP AT T_ROWS INTO DATA(S_ROWS).
			READ TABLE <FS_DATA_FR> ASSIGNING FIELD-SYMBOL(<FS_DATA>) INDEX S_ROWS-ROW_ID.
			IF SY-SUBRC = 0.
				INSERT <FS_DATA> INTO <FS_DATA_TO> INDEX LV_INS_IDX.
				LT_INSTED_ROW = VALUE #( BASE LT_INSTED_ROW ( ROW_ID = CONV #( LV_INS_IDX ) ) ).
				LV_INS_IDX += 1.
			ENDIF.
		ENDLOOP.

		" - DELETE FROM
		SORT T_ROWS BY ROW_ID DESCENDING.

		LOOP AT T_ROWS INTO S_ROWS.
			DELETE <FS_DATA_FR> INDEX S_ROWS-ROW_ID.
		ENDLOOP.

		" - REFRESH ALV
*		<FS_ALV_FR>->MO_GRID->CHECK_CHANGED_DATA( ).
		<FS_ALV_FR>->MO_GRID->CHECK_CHANGED_DATA( IMPORTING E_VALID = DATA(L_VALID_FR) ).
		IF L_VALID_FR IS INITIAL. LEAVE SCREEN. ENDIF.
		<FS_ALV_FR>->MO_GRID->REFRESH_TABLE_DISPLAY( I_SOFT_REFRESH = 'X'
		                                             IS_STABLE = VALUE #( ROW = 'X' COL = 'X' ) ).
*		<FS_ALV_TO>->MO_GRID->CHECK_CHANGED_DATA( ).
		<FS_ALV_TO>->MO_GRID->CHECK_CHANGED_DATA( IMPORTING E_VALID = DATA(L_VALID_TO) ).
		IF L_VALID_TO IS INITIAL. LEAVE SCREEN. ENDIF.
		<FS_ALV_TO>->MO_GRID->REFRESH_TABLE_DISPLAY( I_SOFT_REFRESH = 'X'
		                                             IS_STABLE = VALUE #( ROW = 'X' COL = 'X' ) ).

		" - MARK MOVED LINES
		"<FS_ALV_TO>->MO_GRID->SET_SELECTED_ROWS( IT_ROW_NO = LT_INSTED_ROW ).
		DATA(LT_CELLS) = VALUE LVC_T_CENO( FOR WA IN LT_INSTED_ROW FOR I = 1 THEN I + 1 WHILE I < 100 ( ROW_ID = WA-ROW_ID COL_ID = CONV #( I ) ) ).
		<FS_ALV_TO>->MO_GRID->SET_SELECTED_CELLS_ID( IT_CELLS = LT_CELLS ).

	ENDMETHOD.









	METHOD MOVE_INSIDE.

		DATA: LT_INSTED_ROW TYPE LVC_T_ROID.

		FIELD-SYMBOLS: <FS_ALV_FR>  TYPE REF TO ZCL_COC_ALV,
					   <FS_DATA_FR> TYPE STANDARD TABLE.

		DATA(LV_FR) = |ALV_{ FROM }|.
		ASSIGN (LV_FR) TO <FS_ALV_FR>.
		               
		CASE FROM.
			WHEN ZCOC_L.
				ASSIGN DATA_LEFT->*  TO <FS_DATA_FR>.
			WHEN ZCOC_R.
				ASSIGN DATA_RIGHT->* TO <FS_DATA_FR>.
		ENDCASE.

		IF T_ROWS IS INITIAL.
			MESSAGE S552(KE0C) DISPLAY LIKE ZCOC_E.
			EXIT.
		ENDIF.

		" - CHECK MIN, MAX INDEX OF SELECTED ROWS
		SORT T_ROWS BY ROW_ID DESCENDING.
		DATA(LV_MAX) = T_ROWS[ 1 ]-ROW_ID.

		SORT T_ROWS BY ROW_ID.
		DATA(LV_MIN) = T_ROWS[ 1 ]-ROW_ID.

		" - CHECK "TO" POSITION
		IF TO_INDEX BETWEEN LV_MIN AND LV_MAX.
			EXIT.
		ELSEIF TO_INDEX < LV_MIN. " DROP POSITION IS UPPER.

			" - INSERT
			DATA(LV_INS_IDX) = TO_INDEX.

			LOOP AT T_ROWS INTO DATA(S_ROWS).
				READ TABLE <FS_DATA_FR> ASSIGNING FIELD-SYMBOL(<FS_DATA>) INDEX S_ROWS-ROW_ID + SY-TABIX - 1.
				IF SY-SUBRC = 0.
					INSERT <FS_DATA> INTO <FS_DATA_FR> INDEX LV_INS_IDX.
					LT_INSTED_ROW = VALUE #( BASE LT_INSTED_ROW ( ROW_ID = CONV #( LV_INS_IDX ) ) ).
					LV_INS_IDX += 1.
				ENDIF.
			ENDLOOP.

			" - DELETE FROM
			SORT T_ROWS BY ROW_ID DESCENDING.

			LOOP AT T_ROWS INTO S_ROWS.
				DELETE <FS_DATA_FR> INDEX S_ROWS-ROW_ID + LINES( T_ROWS ).
			ENDLOOP.

		ELSEIF TO_INDEX > LV_MAX. " DROP POSITION IS BELOW
			
			" - INSERT
			LV_INS_IDX = TO_INDEX + 1.

			LOOP AT T_ROWS INTO S_ROWS.
				READ TABLE <FS_DATA_FR> ASSIGNING <FS_DATA> INDEX S_ROWS-ROW_ID.
				IF SY-SUBRC = 0.
					INSERT <FS_DATA> INTO <FS_DATA_FR> INDEX LV_INS_IDX.
					LT_INSTED_ROW = VALUE #( BASE LT_INSTED_ROW ( ROW_ID = CONV #( LV_INS_IDX - LINES( T_ROWS ) ) ) ).
					LV_INS_IDX += 1.
				ENDIF.
			ENDLOOP.

			" - DELETE FROM
			SORT T_ROWS BY ROW_ID DESCENDING.

			LOOP AT T_ROWS INTO S_ROWS.
				DELETE <FS_DATA_FR> INDEX S_ROWS-ROW_ID.
			ENDLOOP.

		ENDIF.

		" - REFRESH ALV
		<FS_ALV_FR>->MO_GRID->CHECK_CHANGED_DATA( ).
		<FS_ALV_FR>->MO_GRID->REFRESH_TABLE_DISPLAY( I_SOFT_REFRESH = 'X'
		                                             IS_STABLE = VALUE #( ROW = 'X' COL = 'X' ) ).

		<FS_ALV_FR>->MO_GRID->SET_SELECTED_ROWS( IT_ROW_NO = LT_INSTED_ROW ).

	ENDMETHOD.
ENDCLASS.			